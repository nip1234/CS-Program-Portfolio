# CS Program GitHub Portfolio

This repository is a portfolio of projects and assignments I completed during my Computer Science coursework. It highlights my understanding of programming concepts, data structures, algorithms, and software development practices. Beyond showcasing technical skills, this portfolio also reflects on my problem-solving process and how my approach to designing software has grown.

---

## Purpose

The primary goals of this portfolio are to:

- **Showcase Skills**: Demonstrate my abilities in C++, data structures (Binary Search Trees, Hash Tables, Linked Lists), algorithm design, and problem-solving.
- **Track Progress**: Document my learning journey and the evolution of my programming skills throughout the course.
- **Share Work**: Provide a centralized location for instructors and potential employers to review my projects.

---

## Projects Included

### Project Two: Course Advising Program
- **Problem I Solved**: Academic advisors often need a way to manage and display course information efficiently. I built a C++ command-line program that loads course data from a CSV file and helps advisors find courses and prerequisites.
- **Approach**: I used a Binary Search Tree (BST) to store course objects, which allowed me to efficiently insert, search, and print courses in sorted order. I designed a simple menu interface and implemented error handling to make the tool user-friendly.
- **Roadblocks and Solutions**: One challenge was ensuring that data loaded correctly from the CSV file. I overcame this by carefully handling file I/O errors and validating input data. I also encountered edge cases with tree balancing and ensured my program could handle skewed data gracefully.
- **Concepts Demonstrated**: Binary Search Trees, file I/O, string manipulation, algorithm design, and object-oriented programming principles.

---

### Project One: Data Structure Analysis
- **Problem I Solved**: I needed to determine which data structure was most effective for storing and retrieving course information. I compared Linked Lists, Hash Tables, and Binary Search Trees.
- **Approach**: I analyzed each data structure based on runtime complexity and memory usage, focusing on operations like loading courses, searching for a course, and printing courses in sorted order.
- **Findings**:  
  - Linked List: Simple and memory-efficient, but slow for searches and sorting.  
  - Hash Table: Very fast on average but unpredictable in the worst case and lacks inherent ordering.  
  - Binary Search Tree: Balanced performance, especially efficient for printing sorted data.  
- **Recommendation**: The BST is the most suitable structure for this project because it balances searching efficiency with the ability to naturally print courses in sorted order.

---

## Reflection

- **Problem-Solving**: Each project started with a clear problem, such as helping advisors manage course data or analyzing the tradeoffs of data structures. I learned to carefully align my solution with the requirements.  
- **Importance of Data Structures**: Working with multiple data structures deepened my understanding of how they impact program performance and usability. Choosing the right structure is critical for writing efficient software.  
- **Overcoming Challenges**: I faced difficulties with file I/O, error handling, and unbalanced trees. By breaking problems into smaller pieces and testing edge cases, I was able to resolve these challenges.  
- **Growth in Software Design**: These projects expanded my approach to software design. I now focus more on evaluating tradeoffs, writing modular code, and selecting the right tools for the problem at hand.  
- **Maintainable, Readable, Adaptable Code**: I improved at writing code that is structured, commented, and easy to extend. Using OOP principles and separating functionality into clear components has made my programs more maintainable and adaptable.

---
